package cmd

import (
	"context"
	"fmt"
	"strings"
	"encoding/json"
	"github.com/charmbracelet/log"
	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	"github.com/spf13/pflag"
	"github.com/whitfieldsdad/go-atomic-red-team/atomic_red_team"
)

var testsCmd = &cobra.Command{
	Use:     "tests",
	Aliases: []string{"test"},
	Short:   "Tests",
}

var discoverTestsCmd = &cobra.Command{
	Use:     "discover",
	Aliases: []string{"d"},
	Short:   "Discover path to atomics directory",
	Run: func(cmd *cobra.Command, args []string) {
		dir, err := getAtomicsDir(cmd.Flags())
		if err != nil {
			log.Fatalf("Failed to find atomics directory: %s\n", err)
		}
		fmt.Println(dir)
	},
}

func getAtomicsDir(flags *pflag.FlagSet) (string, error) {
	atomicsDir, _ := flags.GetString("atomics-dir")
	autoDiscover, _ := flags.GetBool("auto-discover")
	if atomicsDir != "" {
		return atomicsDir, nil
	}
	atomicsDir = atomic_red_team.DefaultAtomicsDir
	if atomicsDir != "" {
		return atomicsDir, nil
	}
	if autoDiscover {
		return atomic_red_team.FindAtomicsDir()
	}
	return "", errors.New("path to atomics directory is required")
}

var listTestsCmd = &cobra.Command{
	Use:     "list",
	Aliases: []string{"ls"},
	Short:   "List tests",
	Run: func(cmd *cobra.Command, args []string) {
		flags := cmd.Flags()
		outputFormat, _ := flags.GetString("output-format")

		tests, err := listTests(flags)
		if err != nil {
			log.Fatalf("Failed to list tests: %s\n", err)
		}

		if outputFormat == JsonOutputFormat {
			blob, err := json.MarshalIndent(tests, "", "  ")
			if err != nil {
				log.Fatalf("Failed to marshal tests: %s\n", err)
			}
			fmt.Println(string(blob))
		} else {
			for _, test := range tests {
				if outputFormat == JsonlOutputFormat {
					PrintJson(test)
				} else if outputFormat == BriefOutputFormat {
					line := fmt.Sprintf("%s: %s - %s (%s)", test.AttackTechniqueId, test.AttackTechniqueName, test.Name, test.AutoGeneratedGuid)
					fmt.Println(line)
	
				} else if outputFormat == PlainOutputFormat {
					separator := strings.Repeat("-", 80)
					lines := []string{
						separator,
						fmt.Sprintf("ATT&CK technique: %s: %s", test.AttackTechniqueId, test.AttackTechniqueName),
						fmt.Sprintf("Atomic test name: %s", test.Name),
						fmt.Sprintf("Atomic test GUID: %s", test.AutoGeneratedGuid),
						fmt.Sprintf("Description: %s", test.Description),
						fmt.Sprintf("Executor: %s", test.Executor.Name),
						fmt.Sprintf("Elevation required: %v", test.Executor.ElevationRequired),
						"",
						fmt.Sprintf("Commands:\n%s", test.Executor.Command),
					}
					if test.Executor.CleanupCommand != "" {
						lines = append(lines, fmt.Sprintf("Cleanup commands:\n%s", test.Executor.CleanupCommand))
					}
					for _, line := range lines {
						fmt.Println(line)
					}
				} else {
					log.Fatalf("Invalid output format: %s\n", outputFormat)
				}
			}
		}
	},
}

var executeTestsCmd = &cobra.Command{
	Use:     "run",
	Aliases: []string{"exec", "execute", "x"},
	Short:   "Run tests",
	Run: func(cmd *cobra.Command, args []string) {
		flags := cmd.Flags()
		atomicsDir, _ := flags.GetString("atomics-dir")
		tests, err := listTests(flags)
		if err != nil {
			log.Fatalf("Failed to list tests: %s\n", err)
		}
		ctx := context.Background()
		opts := atomic_red_team.TestOptions{
			AtomicsDir: atomicsDir,
		}
		for _, test := range tests {
			result := test.Run(ctx, opts)
			PrintJson(result)
		}
	},
}

var countTestsCmd = &cobra.Command{
	Use:     "count",
	Aliases: []string{"n"},
	Short:   "Count tests",
	Run: func(cmd *cobra.Command, args []string) {
		flags := cmd.Flags()
		tests, err := listTests(flags)
		if err != nil {
			log.Fatalf("Failed to list tests: %s\n", err)
		}
		fmt.Println(len(tests))
	},
}

var dependenciesCmd = &cobra.Command{
	Use:     "dependencies",
	Aliases: []string{"dependency", "deps", "dep", "test-dependencies", "test-dependency", "test-deps", "test-dep"},
	Short:   "Test dependencies",
}

var listDependenciesCmd = &cobra.Command{
	Use:     "list",
	Aliases: listCommandAliases,
	Short:   "List dependencies",
	Run: func(cmd *cobra.Command, args []string) {
		deps, err := listDependencies(cmd.Flags())
		if err != nil {
			log.Fatalf("Failed to list dependencies: %s\n", err)
		}
		for _, dep := range deps {
			PrintJson(dep)
		}
	},
}

var countDependenciesCmd = &cobra.Command{
	Use:     "count",
	Aliases: countCommandAliases,
	Short:   "List dependencies",
	Run: func(cmd *cobra.Command, args []string) {
		deps, err := listDependencies(cmd.Flags())
		if err != nil {
			log.Fatalf("Failed to list dependencies: %s\n", err)
		}
		fmt.Println(len(deps))
	},
}

var checkDependenciesCmd = &cobra.Command{
	Use:   "check",
	Short: "Check dependencies",
	Run: func(cmd *cobra.Command, args []string) {
		deps, err := listDependencies(cmd.Flags())
		if err != nil {
			log.Fatalf("Failed to list dependencies: %s\n", err)
		}
		ctx := context.Background()
		for _, dep := range deps {
			result, err := dep.Check(ctx)
			if err != nil {
				log.Fatalf("Failed to check dependency: %s\n", err)
			}
			PrintJson(result)
		}
	},
}

var resolveDependenciesCmd = &cobra.Command{
	Use:   "resolve",
	Short: "Resolve dependencies",
	Run: func(cmd *cobra.Command, args []string) {
		deps, err := listDependencies(cmd.Flags())
		if err != nil {
			log.Fatalf("Failed to list dependencies: %s\n", err)
		}
		ctx := context.Background()
		for _, dep := range deps {
			result, err := dep.Resolve(ctx)
			if err != nil {
				log.Fatalf("Failed to resolve dependency: %s\n", err)
			}
			PrintJson(result)
		}
	},
}

func listTests(flags *pflag.FlagSet) ([]atomic_red_team.Test, error) {
	atomicsDir, err := getAtomicsDir(flags)
	if err != nil {
		return nil, errors.Wrap(err, "failed to get atomics directory")
	}
	client, err := atomic_red_team.NewClient(atomicsDir)
	if err != nil {
		return nil, errors.Wrap(err, "failed to create client")
	}
	testFiltersFromFiles := getTestFiltersFromFiles(flags)
	testFiltersFromCommandLine := getTestFiltersFromCommandLineFlags(flags)

	// If test filters are passed in through both files and the command line, perform hierarchical filtering.
	var tests []atomic_red_team.Test
	if len(testFiltersFromFiles) > 0 && len(testFiltersFromCommandLine) > 0 {
		log.Debug("Test filters were passed in through both files and the command line. Filtering tests hierarchically.")
		allTests, err := client.ListTests(testFiltersFromFiles)
		if err != nil {
			return nil, errors.Wrap(err, "failed to list tests")
		}
		for _, test := range allTests {
			if test.MatchesAnyFilter(testFiltersFromCommandLine) {
				tests = append(tests, test)
			}
		}
		return tests, nil
	}

	// Otherwise, just list the tests.
	if len(testFiltersFromFiles) > 0 {
		log.Debug("Test filters were passed in through files. Filtering tests.")
		tests, err = client.ListTests(testFiltersFromFiles)
	} else if len(testFiltersFromCommandLine) > 0 {
		log.Debug("Test filters were passed in through the command line. Filtering tests.")
		tests, err = client.ListTests(testFiltersFromCommandLine)
	} else {
		log.Debug("No test filters were passed in. Listing all tests.")
		tests, err = client.ListTests(nil)
	}
	if err != nil {
		return nil, errors.Wrap(err, "failed to list tests")
	}
	return tests, nil
}

func listDependencies(flags *pflag.FlagSet) ([]atomic_red_team.Dependency, error) {
	tests, err := listTests(flags)
	if err != nil {
		return nil, err
	}
	var dependencies []atomic_red_team.Dependency
	for _, test := range tests {
		dependencies = append(dependencies, test.Dependencies...)
	}
	return dependencies, nil
}

func getTestFiltersFromCommandLineFlags(flags *pflag.FlagSet) []atomic_red_team.TestFilter {
	f := &atomic_red_team.TestFilter{}
	f.Ids, _ = flags.GetStringSlice("id")
	f.Names, _ = flags.GetStringSlice("name")
	f.Descriptions, _ = flags.GetStringSlice("description")
	f.AttackTechniqueIds, _ = flags.GetStringSlice("attack-technique-id")
	f.Platforms, _ = flags.GetStringSlice("platform")
	f.ExecutorTypes, _ = flags.GetStringSlice("executor-type")
	f.ElevationRequired, _ = getNullableBool("elevation-required", flags)

	if !f.Empty() {
		return []atomic_red_team.TestFilter{*f}
	}
	return nil
}

func getTestFiltersFromFiles(flags *pflag.FlagSet) []atomic_red_team.TestFilter {
	var testFilters []atomic_red_team.TestFilter
	testPlanPaths, _ := flags.GetStringSlice("plan")
	if len(testPlanPaths) > 0 {
		for _, testPlanPath := range testPlanPaths {
			testPlan, err := atomic_red_team.ReadTestPlan(testPlanPath)
			if err != nil {
				log.Fatalf("Failed to read test plan: %s\n", err)
			}
			testFilters = append(testFilters, testPlan.GetTestFilters()...)
		}
	}
	return testFilters
}

func init() {
	rootCmd.AddCommand(testsCmd)
	testsCmd.AddCommand(listTestsCmd, countTestsCmd, executeTestsCmd, discoverTestsCmd)

	discoverTestsCmd.Flags().StringP("atomics-dir", "", atomic_red_team.DefaultAtomicsDir, "Path to atomic-red-team/atomics directory")
	discoverTestsCmd.Flags().BoolP("auto-discover", "", true, "Auto-discover atomic-red-team/atomics directory")

	rootCmd.AddCommand(dependenciesCmd)
	dependenciesCmd.AddCommand(listDependenciesCmd, countDependenciesCmd, checkDependenciesCmd, resolveDependenciesCmd)

	flagset := pflag.FlagSet{}
	flagset.StringP("atomics-dir", "", atomic_red_team.DefaultAtomicsDir, "Path to atomic-red-team/atomics directory")
	flagset.BoolP("auto-discover", "", false, "Auto-discover atomic-red-team/atomics directory")

	flagset.StringSliceP("id", "", []string{}, "Test IDs")
	flagset.StringSliceP("name", "", []string{}, "Test names")
	flagset.StringSliceP("description", "", []string{}, "Test descriptions")
	flagset.StringSliceP("attack-technique-id", "", []string{}, "ATT&CK technique IDs")
	flagset.StringSliceP("attack-technique-name", "", []string{}, "ATT&CK technique names")
	flagset.StringSliceP("platform", "", []string{}, "Platforms")
	flagset.StringSliceP("plan", "p", []string{}, "Test plans")
	flagset.StringSliceP("executor-type", "t", []string{}, "Executor types")
	flagset.BoolP("elevation-required", "", false, "Elevation required")

	// Use the same flags for all test-related commands.
	listTestsCmd.Flags().AddFlagSet(&flagset)
	listTestsCmd.Flags().StringP("output-format", "", DefaultOutputFormat, fmt.Sprintf("Output format (%s)", strings.Join(OutputFormats, ", ")))

	countTestsCmd.Flags().AddFlagSet(&flagset)
	executeTestsCmd.Flags().AddFlagSet(&flagset)

	listDependenciesCmd.Flags().AddFlagSet(&flagset)
	countDependenciesCmd.Flags().AddFlagSet(&flagset)
	checkDependenciesCmd.Flags().AddFlagSet(&flagset)
}

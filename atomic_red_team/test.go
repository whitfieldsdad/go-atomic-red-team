package atomic_red_team

import (
	"context"
	"fmt"
	"runtime"
	"strings"
	"time"

	"github.com/charmbracelet/log"
	"github.com/pkg/errors"
	"golang.org/x/exp/slices"
)

// Test contains the information needed to execute a single test.
type Test struct {
	Name                   string             `json:"name,omitempty" yaml:"name,omitempty"`
	AutoGeneratedGuid      string             `json:"auto_generated_guid,omitempty" yaml:"auto_generated_guid,omitempty"`
	Description            string             `json:"description,omitempty" yaml:"description,omitempty"`
	SupportedPlatforms     []string           `json:"supported_platforms,omitempty" yaml:"supported_platforms,omitempty"`
	InputArguments         map[string]ArgSpec `json:"input_arguments,omitempty" yaml:"input_arguments,omitempty"`
	DependencyExecutorName string             `json:"dependency_executor_name,omitempty" yaml:"dependency_executor_name,omitempty"`
	Dependencies           []Dependency       `json:"dependencies,omitempty" yaml:"dependencies,omitempty"`
	Executor               Executor           `json:"executor,omitempty" yaml:"executor,omitempty"`
	AttackTechniqueId      string             `json:"attack_technique_id,omitempty" yaml:"attack_technique_id,omitempty"`
	AttackTechniqueName    string             `json:"attack_technique_name,omitempty" yaml:"attack_technique_name,omitempty"`
}

// MatchesAnyFilter returns true if the test matches any of the provided filters.
func (t Test) MatchesAnyFilter(testFilters []TestFilter) bool {
	if len(testFilters) == 0 {
		return true
	}
	for _, testFilter := range testFilters {
		if testFilter.Matches(t) {
			return true
		}
	}
	return false
}

// MatchesCurrentPlatform checks if the test is supported on the current platform.
func (t Test) MatchesCurrentPlatform() bool {
	return t.MatchesPlatform(runtime.GOOS)
}

// MatchesPlatform checks if the test is supported on the provided platform.
func (t Test) MatchesPlatform(platform string) bool {
	if platform == "darwin" {
		platform = "macos"
	}
	return slices.Contains(t.SupportedPlatforms, platform)
}

// Run executes the test.
func (t Test) Run(ctx context.Context, opts TestOptions) TestResult {
	result := TestResult{
		Id:     NewUUID4(),
		Time:   time.Now(),
		TestId: t.AutoGeneratedGuid,
	}
	err := t.checkRequirements()
	if err != nil {
		result.Error = err.Error()
		return result
	}

	// Execute the test command.
	log.Info("Executing test command")
	executedCommand, err := t.executeCommand(ctx, opts.AtomicsDir, t.Executor.Command, t.Executor.Name)
	if err != nil {
		result.Error = err.Error()
		return result
	}
	result.ExecutedCommands = append(result.ExecutedCommands, *executedCommand)
	log.Info("Executed test command")

	// Execute the test command.
	if t.Executor.CleanupCommand != "" {
		log.Infof("Executing cleanup command: %s", t.Executor.CleanupCommand)
		executedCommand, err := t.executeCommand(ctx, opts.AtomicsDir, t.Executor.CleanupCommand, t.Executor.Name)
		if err != nil {
			result.Error = err.Error()
			return result
		}
		result.ExecutedCommands = append(result.ExecutedCommands, *executedCommand)
		log.Info("Executed cleanup command")
	}
	return result
}

func (t Test) executeCommand(ctx context.Context, atomicsDir, command, commandType string) (*ExecutedCommand, error) {
	command, err := t.prepareCommand(command, atomicsDir)
	if err != nil {
		return nil, errors.Wrap(err, "failed to prepare command")
	}
	executedCommand, err := ExecuteCommand(ctx, command, commandType)
	if err != nil {
		return nil, errors.Wrap(err, "failed to execute command")
	}
	return executedCommand, nil
}

func (t Test) prepareCommand(command, atomicsDir string) (string, error) {
	kwargs := map[string]string{}
	for k, v := range t.InputArguments {
		kwargs[k] = v.DefaultValue
	}
	command = interpolateKwargs(command, kwargs)
	command, err := patchAtomicsDir(command, atomicsDir)
	if err != nil {
		return "", errors.Wrap(err, "failed to patch PathToAtomicsFolder")
	}
	return command, nil
}

func (t Test) checkRequirements() error {
	executor := t.Executor
	if executor.Name == "manual" {
		return errors.New("manual tests are not supported")
	}
	if !t.MatchesCurrentPlatform() {
		return errors.New("unsupported platform")
	}
	if executor.ElevationRequired {
		elevated, err := CurrentProcessIsElevated()
		if err != nil {
			return errors.Wrap(err, "failed to check if current process is elevated")
		}
		if !elevated {
			return errors.New("test requires elevation")
		}
	}
	return nil
}

type ArgSpec struct {
	Description  string `json:"description" yaml:"description"`
	Type         string `json:"type" yaml:"type"`
	DefaultValue string `json:"default" yaml:"default"`
}

type Executor struct {
	Name              string `json:"name" yaml:"name"`
	ElevationRequired bool   `json:"elevation_required" yaml:"elevation_required"`
	Command           string `json:"command" yaml:"command"`
	CleanupCommand    string `json:"cleanup_command,omitempty" yaml:"cleanup_command,omitempty"`
}

type Dependency struct {
	Description      string `json:"description" yaml:"description"`
	PrereqCommand    string `json:"prereq_command" yaml:"prereq_command"`
	GetPrereqCommand string `json:"get_prereq_command" yaml:"get_prereq_command"`
	executorType     string `json:"-" yaml:"-"`
}

// TODO
func (d Dependency) Check(ctx context.Context) (DependencyCheckResult, error) {
	log.Infof("Checking dependency: %s", d.Description)
	executedCommand, err := ExecuteCommand(ctx, d.PrereqCommand, d.executorType)
	if err != nil {
		result := NewDependencyCheckResult(d, nil, false, err)
		return result, err
	}
	resolved := *executedCommand.Process.ExitCode != 0
	if resolved {
		log.Infof("Dependency met: %s", d.Description)
	} else {
		log.Infof("Dependency not met: %s", d.Description)
	}
	result := NewDependencyCheckResult(d, []ExecutedCommand{*executedCommand}, resolved, nil)
	return result, nil
}

func (d Dependency) Resolve(ctx context.Context) (DependencyCheckResult, error) {
	log.Infof("Resolving dependency: %s", d.Description)

	// Check if the dependency is already resolved.
	checkResult, err := d.Check(ctx)
	if err != nil {
		return checkResult, err
	}
	if checkResult.Resolved {
		return checkResult, nil
	}

	// If the dependency is not resolve, attempt to resolve it.
	result := &DependencyCheckResult{
		Id:               NewUUID4(),
		Time:             time.Now(),
		Dependency:       d,
		ExecutedCommands: checkResult.ExecutedCommands,
	}
	executedCommand, err := ExecuteCommand(ctx, d.GetPrereqCommand, d.executorType)
	if executedCommand != nil {
		result.ExecutedCommands = append(result.ExecutedCommands, *executedCommand)
	}
	if err != nil {
		result.Error = err.Error()
		return *result, err
	}

	// Check if the dependency is resolved.
	checkResult, err = d.Check(ctx)
	if len(checkResult.ExecutedCommands) > 0 {
		result.ExecutedCommands = append(result.ExecutedCommands, checkResult.ExecutedCommands...)
	}
	if err != nil {
		return *result, err
	}
	result.Resolved = checkResult.Resolved
	if result.Resolved {
		log.Infof("Dependency resolved: %s", d.Description)
	} else {
		log.Errorf("Failed to resolve dependency: %s", d.Description)
	}
	return *result, nil
}

type DependencyCheckResult struct {
	Id               string            `json:"id" yaml:"id"`
	Time             time.Time         `json:"time" yaml:"time"`
	Dependency       Dependency        `json:"dependency" yaml:"dependency"`
	ExecutedCommands []ExecutedCommand `json:"executed_commands" yaml:"executed_commands"`
	Error            string            `json:"error" yaml:"error"`
	Resolved         bool              `json:"resolved" yaml:"resolved"`
}

func NewDependencyCheckResult(dependency Dependency, executedCommands []ExecutedCommand, resolved bool, err error) DependencyCheckResult {
	result := DependencyCheckResult{
		Id:               NewUUID4(),
		Time:             time.Now(),
		Dependency:       dependency,
		ExecutedCommands: executedCommands,
		Resolved:         resolved,
	}
	if err != nil {
		result.Error = err.Error()
	}
	return result
}

func patchAtomicsDir(command, atomicsDir string) (string, error) {
	if atomicsDir == "" {
		return "", errors.New("a directory is required")
	}
	command = strings.Replace(command, "PathToAtomicsFolder", atomicsDir, -1)
	return command, nil
}

func interpolateKwargs(command string, kwargs map[string]string) string {
	for k, v := range kwargs {
		k = fmt.Sprintf("#{%s}", k)
		command = strings.Replace(command, k, v, -1)
	}
	return command
}

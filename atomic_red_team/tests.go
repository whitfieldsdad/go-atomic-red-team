package atomic_red_team

import (
	"context"
	"fmt"
	"runtime"
	"strings"
	"time"

	"github.com/pkg/errors"
	"golang.org/x/exp/slices"
)

type Test struct {
	Name                   string             `json:"name,omitempty" yaml:"name,omitempty"`
	AutoGeneratedGuid      string             `json:"auto_generated_guid,omitempty" yaml:"auto_generated_guid,omitempty"`
	Description            string             `json:"description,omitempty" yaml:"description,omitempty"`
	SupportedPlatforms     []string           `json:"supported_platforms,omitempty" yaml:"supported_platforms,omitempty"`
	InputArguments         map[string]ArgSpec `json:"input_arguments,omitempty" yaml:"input_arguments,omitempty"`
	DependencyExecutorName string             `json:"dependency_executor_name,omitempty" yaml:"dependency_executor_name,omitempty"`
	Dependencies           []Dependency       `json:"dependencies,omitempty" yaml:"dependencies,omitempty"`
	Executor               Executor           `json:"executor,omitempty" yaml:"executor,omitempty"`
	AttackTechniqueId      string             `json:"-" yaml:"-"`
	AttackTechniqueName    string             `json:"-" yaml:"-"`
}

func (t Test) DisplayName() string {
	return fmt.Sprintf("%s: %s - %s", t.AttackTechniqueId, t.AttackTechniqueName, t.Name)
}

func (t Test) IsManual() bool {
	return t.Executor.Name == "manual" || t.DependencyExecutorName == "manual"
}

func (t Test) MatchesAnyFilter(testFilters []TestFilter) bool {
	if len(testFilters) == 0 {
		return true
	}
	for _, testFilter := range testFilters {
		if testFilter.Matches(t) {
			return true
		}
	}
	return false
}

func (t Test) MatchesCurrentPlatform() bool {
	return t.MatchesPlatform(runtime.GOOS)
}

func (t Test) MatchesPlatform(platform string) bool {
	if platform == "darwin" {
		platform = "macos"
	}
	return slices.Contains(t.SupportedPlatforms, platform)
}

func (t Test) SetInputArguments(kwargs map[string]string) {
	for k, v := range kwargs {
		argSpec, ok := t.InputArguments[k]
		if !ok {
			return
		}
		argSpec.DefaultValue = v
		t.InputArguments[k] = argSpec
	}
}

// TODO: wrap commands
func (t Test) Run(ctx context.Context, atomicsDir string, opts *TestOptions) (*TestResult, error) {
	if opts == nil {
		opts = NewTestOptions()
	}
	now := time.Now()
	err := t.checkRequirements()
	if err != nil {
		return nil, err
	}

	var executedCommands []ExecutedCommand

	// Execute the primary test command.
	executedCommand, err := t.executeCommand(ctx, t.Executor.Command, t.Executor.Name, nil)
	if err != nil {
		return nil, errors.Wrap(err, "failed to execute command")
	}
	executedCommands = append(executedCommands, *executedCommand)

	// Execute the cleanup command if one is specified.
	cleanupCommand := t.Executor.CleanupCommand
	if cleanupCommand != "" {
		executedCommand, err := t.executeCommand(ctx, cleanupCommand, t.Executor.Name, opts.CommandOptions)
		if err != nil {
			return nil, errors.Wrap(err, "failed to execute cleanup command")
		}
		executedCommands = append(executedCommands, *executedCommand)
	}
	testResult := &TestResult{
		Id:               NewUUID4(),
		Time:             now,
		Test:             t,
		ExecutedCommands: executedCommands,
	}
	return testResult, nil
}

func (t Test) checkRequirements() error {
	executor := t.Executor
	if executor.Name == "manual" {
		return errors.New("manual tests are not supported")
	}
	if !t.MatchesCurrentPlatform() {
		return errors.New("unsupported platform")
	}
	if executor.ElevationRequired {
		elevated, err := IsElevated()
		if err != nil {
			return errors.Wrap(err, "failed to check if current process is elevated")
		}
		if !elevated {
			return errors.New("test requires elevation")
		}
	}
	return nil
}

func (t Test) executeCommand(ctx context.Context, command, commandType string, opts *CommandOptions) (*ExecutedCommand, error) {
	kwargs := map[string]string{}
	for k, v := range t.InputArguments {
		kwargs[k] = v.DefaultValue
	}
	c, err := NewCommand(command, commandType)
	if err != nil {
		return nil, errors.Wrap(err, "failed to create command")
	}
	return c.Execute(ctx, opts)
}

type ArgSpec struct {
	Description  string `json:"description" yaml:"description"`
	Type         string `json:"type" yaml:"type"`
	DefaultValue string `json:"default" yaml:"default"`
}

type Executor struct {
	Name              string `json:"name" yaml:"name"`
	ElevationRequired bool   `json:"elevation_required" yaml:"elevation_required"`
	Command           string `json:"command" yaml:"command"`
	CleanupCommand    string `json:"cleanup_command,omitempty" yaml:"cleanup_command,omitempty"`
}

type Dependency struct {
	Description      string `json:"description" yaml:"description"`
	PrereqCommand    string `json:"prereq_command" yaml:"prereq_command"`
	GetPrereqCommand string `json:"get_prereq_command" yaml:"get_prereq_command"`
	executorName     string `json:"-" yaml:"-"`
}

type DependencyCheckResult struct {
	ExecutedCommands []ExecutedCommand `json:"executed_commands,omitempty" yaml:"executed_commands,omitempty"`
	Resolved         bool              `json:"resolved" yaml:"resolved"`
}

func (d Dependency) Check(ctx context.Context, opts *TestOptions) (*DependencyCheckResult, error) {
	if opts == nil {
		opts = NewTestOptions()
	}
	var executedCommands []ExecutedCommand

	// Check the dependency.
	subcommands, resolved, err := d.checkDependency(ctx, *opts)
	if err != nil {
		return nil, errors.Wrap(err, "failed to check dependency")
	}
	executedCommands = append(executedCommands, subcommands...)
	result := &DependencyCheckResult{
		ExecutedCommands: executedCommands,
		Resolved:         resolved,
	}
	return result, nil
}

func (d Dependency) checkDependency(ctx context.Context, opts TestOptions) ([]ExecutedCommand, bool, error) {
	var executedCommands []ExecutedCommand

	executedCommand, err := ExecuteCommand(ctx, d.PrereqCommand, d.executorName, opts.CommandOptions)
	if err != nil {
		return nil, false, errors.Wrap(err, "failed to check dependency")
	}
	executedCommands = append(executedCommands, *executedCommand)
	resolved := executedCommand.ExitCode == 0
	return executedCommands, resolved, nil
}

func (d Dependency) Resolve(ctx context.Context, opts *TestOptions) ([]ExecutedCommand, bool, error) {
	if opts == nil {
		opts = NewTestOptions()
	}
	var executedCommands []ExecutedCommand

	// Check if the dependency has been resolved.
	subcommands, resolved, err := d.checkDependency(ctx, *opts)
	if err != nil {
		return nil, false, errors.Wrap(err, "failed to check dependency")
	}
	executedCommands = append(executedCommands, subcommands...)
	if resolved {
		return executedCommands, true, nil
	}

	// Resolve the dependency.
	subcommand, err := ExecuteCommand(ctx, d.GetPrereqCommand, d.executorName, opts.CommandOptions)
	if err != nil {
		return nil, false, errors.Wrap(err, "failed to execute dependency resolution command")
	}
	executedCommands = append(executedCommands, *subcommand)

	// Check if the dependency has been resolved.
	subcommands, resolved, err = d.checkDependency(ctx, *opts)
	if err != nil {
		return nil, false, errors.Wrap(err, "failed to check dependency")
	}
	executedCommands = append(executedCommands, subcommands...)
	return executedCommands, resolved, nil
}

func setCommandArgs(command, atomicsDir string, kwargs map[string]string) (string, error) {
	command, err := patchAtomicsDir(command, atomicsDir)
	if err != nil {
		return "", errors.Wrap(err, "failed to patch PathToAtomicsDir")
	}
	if kwargs != nil {
		command = interpolateKwargs(command, kwargs)
	}
	return command, nil
}

func patchAtomicsDir(command, atomicsDir string) (string, error) {
	if atomicsDir == "" {
		return command, nil
	}
	atomicsDir = strings.ReplaceAll(atomicsDir, "\\", "\\\\")
	return strings.ReplaceAll(command, "PathToAtomicsDir", atomicsDir), nil
}

func interpolateKwargs(command string, kwargs map[string]string) string {
	for k, v := range kwargs {
		command = strings.ReplaceAll(command, fmt.Sprintf("{{%s}}", k), v)
	}
	return command
}

func setInputArguments(tests []Test, kwargs map[string]string) []Test {
	for i, _ := range tests {
		tests[i].SetInputArguments(kwargs)
	}
	return tests
}

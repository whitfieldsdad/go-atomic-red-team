package atomic_red_team

import (
	"runtime"
)

type TestFilter struct {
	Ids                []string `json:"ids,omitempty"`
	Names              []string `json:"names,omitempty"`
	Descriptions       []string `json:"descriptions,omitempty"`
	Platforms          []string `json:"platforms,omitempty"`
	ExecutorTypes      []string `json:"executor_types,omitempty"`
	ElevationRequired  *bool    `json:"elevation_required,omitempty"`
	AttackTechniqueIds []string `json:"attack_technique_ids,omitempty"`
}

func NewTestFilter() (*TestFilter, error) {
	f := &TestFilter{}
	return f, nil
}

func (f *TestFilter) SetDefaultPlatform() error {
	f.Platforms = append(f.Platforms, runtime.GOOS)
	return nil
}

func (f TestFilter) Empty() bool {
	if f.ElevationRequired != nil {
		return false
	}
	slices := [][]string{
		f.Ids,
		f.Names,
		f.Descriptions,
		f.AttackTechniqueIds,
		f.Platforms,
		f.ExecutorTypes,
	}
	for _, slice := range slices {
		if len(slice) > 0 {
			return false
		}
	}
	return true
}

func (f TestFilter) Matches(t Test) bool {
	if f.Empty() {
		return true
	}
	cmps := []struct {
		Value          []string
		RequiredValues []string
	}{
		{[]string{t.AutoGeneratedGuid}, f.Ids},
		{[]string{t.Name}, f.Names},
		{[]string{t.Description}, f.Descriptions},
		{[]string{t.AttackTechniqueId}, f.AttackTechniqueIds},
		{[]string{t.Executor.Name}, f.ExecutorTypes},
		{t.SupportedPlatforms, f.Platforms},
	}
	for _, cmp := range cmps {
		if len(cmp.RequiredValues) > 0 && !AnyStringMatchesAnyPattern(cmp.Value, cmp.RequiredValues) {
			return false
		}
	}
	if f.ElevationRequired != nil && *f.ElevationRequired != t.Executor.ElevationRequired {
		return false
	}
	return true
}

func removeEmptyTestFilters(filters []TestFilter) []TestFilter {
	var filtered []TestFilter
	for _, filter := range filters {
		if !filter.Empty() {
			filtered = append(filtered, filter)
		}
	}
	return filtered
}

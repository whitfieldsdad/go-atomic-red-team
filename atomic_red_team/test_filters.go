package atomic_red_team

import (
	"runtime"
	"slices"
)

type TestFilter struct {
	Ids                []string `json:"ids,omitempty"`
	Names              []string `json:"names,omitempty"`
	Descriptions       []string `json:"descriptions,omitempty"`
	Platforms          []string `json:"platforms,omitempty"`
	ExecutorTypes      []string `json:"executor_types,omitempty"`
	ElevationRequired  *bool    `json:"elevation_required,omitempty"`
	AttackTechniqueIds []string `json:"attack_technique_ids,omitempty"`
}

func NewTestFilter() (*TestFilter, error) {
	f := &TestFilter{}
	return f, nil
}

func (f *TestFilter) SetDefaultPlatform() error {
	f.Platforms = append(f.Platforms, runtime.GOOS)
	return nil
}

func (f TestFilter) Matches(t Test) bool {
	cmps := []struct {
		Value          []string
		RequiredValues []string
	}{
		{[]string{t.AutoGeneratedGuid}, f.Ids},
		{[]string{t.Name}, f.Names},
		{[]string{t.Description}, f.Descriptions},
		{[]string{t.AttackTechniqueId}, f.AttackTechniqueIds},
		{[]string{t.Executor.Name}, f.ExecutorTypes},
		{t.SupportedPlatforms, f.Platforms},
	}
	for _, cmp := range cmps {
		if len(cmp.RequiredValues) > 0 && !AnyStringMatchesAnyPattern(cmp.Value, cmp.RequiredValues) {
			return false
		}
	}
	if f.ElevationRequired != nil && *f.ElevationRequired != t.Executor.ElevationRequired {
		return false
	}
	return true
}

func getAttackTechniqueIdsFromTestFilters(testFilters []TestFilter) []string {
	var attackTechniqueIds []string
	for _, testFilter := range testFilters {
		for _, attackTechniqueId := range testFilter.AttackTechniqueIds {
			if !slices.Contains(attackTechniqueIds, attackTechniqueId) {
				attackTechniqueIds = append(attackTechniqueIds, attackTechniqueId)
			}
		}
	}
	return attackTechniqueIds
}

func mergeTestFilters(filters ...TestFilter) TestFilter {
	var combined TestFilter
	for _, filter := range filters {
		combined.Ids = append(combined.Ids, filter.Ids...)
		combined.Names = append(combined.Names, filter.Names...)
		combined.Descriptions = append(combined.Descriptions, filter.Descriptions...)
		combined.Platforms = append(combined.Platforms, filter.Platforms...)
		combined.ExecutorTypes = append(combined.ExecutorTypes, filter.ExecutorTypes...)
		if filter.ElevationRequired != nil {
			combined.ElevationRequired = filter.ElevationRequired
		}
		combined.AttackTechniqueIds = append(combined.AttackTechniqueIds, filter.AttackTechniqueIds...)
	}
	return combined
}

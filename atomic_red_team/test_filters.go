package atomic_red_team

import (
	"runtime"
	"slices"
)

type TestFilter struct {
	Ids                     []string `json:"ids" yaml:"ids"`
	Names                   []string `json:"names" yaml:"names"`
	Descriptions            []string `json:"descriptions" yaml:"descriptions"`
	Platforms               []string `json:"platforms" yaml:"platforms"`
	ExecutorTypes           []string `json:"executor_types" yaml:"executor_types"`
	ElevationRequired       *bool    `json:"elevation_required" yaml:"elevation_required"`
	AttackTechniqueIds      []string `json:"attack_technique_ids" yaml:"attack_technique_ids"`
	ReferencesAtomicsFolder *bool    `json:"references_atomics_folder" yaml:"references_atomics_folder"`
}

func NewTestFilter() (*TestFilter, error) {
	f := &TestFilter{}
	return f, nil
}

func (f *TestFilter) SetDefaultPlatform() error {
	f.Platforms = append(f.Platforms, runtime.GOOS)
	return nil
}

func (f TestFilter) Matches(t Test) bool {
	cmps := []struct {
		Value          []string
		RequiredValues []string
	}{
		{[]string{t.AutoGeneratedGuid}, f.Ids},
		{[]string{t.Name}, f.Names},
		{[]string{t.Description}, f.Descriptions},
		{[]string{t.AttackTechniqueId}, f.AttackTechniqueIds},
		{[]string{t.Executor.Name}, f.ExecutorTypes},
		{t.SupportedPlatforms, f.Platforms},
	}
	for _, cmp := range cmps {
		if len(cmp.RequiredValues) > 0 && !AnyStringMatchesAnyPattern(cmp.Value, cmp.RequiredValues) {
			return false
		}
	}
	if f.ElevationRequired != nil && *f.ElevationRequired != t.Executor.ElevationRequired {
		return false
	}
	if f.ReferencesAtomicsFolder != nil && *f.ReferencesAtomicsFolder != t.HasReferencesToAtomicsFolder() {
		return false
	}
	return true
}

func getAttackTechniqueIdsFromTestFilters(testFilters []TestFilter) []string {
	var attackTechniqueIds []string
	for _, testFilter := range testFilters {
		for _, attackTechniqueId := range testFilter.AttackTechniqueIds {
			if !slices.Contains(attackTechniqueIds, attackTechniqueId) {
				attackTechniqueIds = append(attackTechniqueIds, attackTechniqueId)
			}
		}
	}
	return attackTechniqueIds
}

func MergeTestFilters(filters ...TestFilter) *TestFilter {
	combined := &TestFilter{}
	for _, filter := range filters {
		combined.Ids = append(combined.Ids, filter.Ids...)
		combined.Names = append(combined.Names, filter.Names...)
		combined.Descriptions = append(combined.Descriptions, filter.Descriptions...)
		combined.Platforms = append(combined.Platforms, filter.Platforms...)
		combined.ExecutorTypes = append(combined.ExecutorTypes, filter.ExecutorTypes...)
		combined.AttackTechniqueIds = append(combined.AttackTechniqueIds, filter.AttackTechniqueIds...)
	}
	return combined
}

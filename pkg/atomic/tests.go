package atomic

import (
	"context"
	"fmt"
	"runtime"
	"strings"
	"time"

	"github.com/charmbracelet/log"
	"github.com/pkg/errors"
	"github.com/whitfieldsdad/go-building-blocks/pkg/bb"
	"golang.org/x/exp/slices"
)

type Test struct {
	Name                   string             `json:"name,omitempty" yaml:"name,omitempty"`
	AutoGeneratedGuid      string             `json:"auto_generated_guid,omitempty" yaml:"auto_generated_guid,omitempty"`
	Description            string             `json:"description,omitempty" yaml:"description,omitempty"`
	SupportedPlatforms     []string           `json:"supported_platforms,omitempty" yaml:"supported_platforms,omitempty"`
	InputArguments         map[string]ArgSpec `json:"input_arguments,omitempty" yaml:"input_arguments,omitempty"`
	DependencyExecutorName string             `json:"dependency_executor_name,omitempty" yaml:"dependency_executor_name,omitempty"`
	Dependencies           []Dependency       `json:"dependencies,omitempty" yaml:"dependencies,omitempty"`
	Executor               Executor           `json:"executor,omitempty" yaml:"executor,omitempty"`
	AttackTechniqueId      string             `json:"-" yaml:"-"`
	AttackTechniqueName    string             `json:"-" yaml:"-"`
}

func (t Test) GetReferencesToAtomicsFolder() []string {
	var references []string
	for _, command := range t.getCommands() {
		if strings.Contains(command, "PathToAtomicsDir") {
			references = append(references, command)
		}
	}
	return references
}

func (t Test) HasReferencesToAtomicsFolder() bool {
	return len(t.GetReferencesToAtomicsFolder()) > 0
}

func (t Test) getCommands() []string {
	var commands []string
	for _, dependency := range t.Dependencies {
		commands = append(commands, dependency.PrereqCommand, dependency.GetPrereqCommand)
	}
	commands = append(commands, t.Executor.Command)
	if t.Executor.CleanupCommand != "" {
		commands = append(commands, t.Executor.CleanupCommand)
	}
	return commands
}

func (t Test) combineArgs(inputArguments map[string]interface{}) map[string]interface{} {
	return combineArgs(t.InputArguments, inputArguments)
}

func (t Test) GetDisplayName() string {
	return fmt.Sprintf("%s: %s - %s", t.AttackTechniqueId, t.AttackTechniqueName, t.Name)
}

func (t Test) IsManual() bool {
	return t.Executor.Name == "manual" || t.DependencyExecutorName == "manual"
}

func (t Test) MatchesAnyFilter(filters []TestFilter) bool {
	if len(filters) == 0 {
		return true
	}
	for _, filter := range filters {
		if filter.Matches(t) {
			return true
		}
	}
	return false
}

func (t Test) MatchesCurrentPlatform() bool {
	return t.MatchesPlatform(runtime.GOOS)
}

func (t Test) MatchesPlatform(platform string) bool {
	if platform == "darwin" {
		platform = "macos"
	}
	return slices.Contains(t.SupportedPlatforms, platform)
}

func (t Test) Run(ctx context.Context, atomicsDir string, opts *TestOptions) (*TestResult, error) {
	log.Infof("Executing test: %s", t.GetDisplayName())
	if opts == nil {
		opts = NewTestOptions()
	}
	now := time.Now()
	err := t.checkRequirements()
	if err != nil {
		return nil, err
	}
	var executedCommands []bb.ExecutedCommand

	// Combine input arguments.
	inputArguments := t.combineArgs(opts.InputArguments)

	// Resolve dependencies.
	var dependencyResolutionResults []DependencyResolutionResult
	if len(t.Dependencies) > 0 {
		log.Infof("Test has %d dependencies (ID: %s)", len(t.Dependencies), t.AutoGeneratedGuid)
		dependencyResolutionResults, err = t.resolveDependencies(ctx, atomicsDir, inputArguments)
		if err != nil {
			return nil, errors.Wrap(err, "failed to perform dependency resolution")
		}
	}

	// Execute the primary test command.
	command, err := prepareCommand(t.Executor.Command, atomicsDir, inputArguments)
	if err != nil {
		return nil, errors.Wrap(err, "failed to prepare command")
	}
	executedCommand, err := bb.ExecuteCommand(ctx, command, t.Executor.Name, nil)
	if err != nil {
		return nil, errors.Wrap(err, "failed to execute command")
	}
	executedCommands = append(executedCommands, *executedCommand)

	// Execute the cleanup command.
	if t.Executor.CleanupCommand != "" {
		command, err := prepareCommand(t.Executor.CleanupCommand, atomicsDir, inputArguments)
		if err != nil {
			return nil, errors.Wrap(err, "failed to prepare cleanup command")
		}
		executedCommand, err := bb.ExecuteCommand(ctx, command, t.Executor.Name, nil)
		if err != nil {
			return nil, errors.Wrap(err, "failed to execute cleanup command")
		}
		executedCommands = append(executedCommands, *executedCommand)
	}

	testResult := &TestResult{
		Id:               bb.NewUUID4(),
		Time:             now,
		Test:             t,
		ExecutedCommands: executedCommands,
		Dependencies:     dependencyResolutionResults,
	}
	return testResult, nil
}

func (t Test) checkRequirements() error {
	executor := t.Executor
	if executor.Name == "manual" {
		return errors.New("manual tests are not supported")
	}
	if !t.MatchesCurrentPlatform() {
		return errors.New("unsupported platform")
	}
	if executor.ElevationRequired {
		elevated, err := bb.IsElevated()
		if err != nil {
			return errors.Wrap(err, "failed to check if current process is elevated")
		}
		if !elevated {
			return errors.New("test requires elevation")
		}
	}
	return nil
}

func (t Test) resolveDependencies(ctx context.Context, atomicsDir string, inputArguments map[string]interface{}) ([]DependencyResolutionResult, error) {
	var results []DependencyResolutionResult
	for _, dependency := range t.Dependencies {
		result, err := dependency.ResolveDependency(ctx, atomicsDir, inputArguments)
		if err != nil {
			return nil, err
		}
		results = append(results, *result)
	}
	return results, nil
}

type ArgSpec struct {
	Description  string `json:"description" yaml:"description"`
	Type         string `json:"type" yaml:"type"`
	DefaultValue string `json:"default" yaml:"default"`
}

type Executor struct {
	Name              string `json:"name" yaml:"name"`
	ElevationRequired bool   `json:"elevation_required" yaml:"elevation_required"`
	Command           string `json:"command" yaml:"command"`
	CleanupCommand    string `json:"cleanup_command,omitempty" yaml:"cleanup_command,omitempty"`
}

type Dependency struct {
	Description      string             `json:"description" yaml:"description"`
	PrereqCommand    string             `json:"prereq_command" yaml:"prereq_command"`
	GetPrereqCommand string             `json:"get_prereq_command" yaml:"get_prereq_command"`
	ExecutorName     string             `json:"-" yaml:"-"`
	InputArguments   map[string]ArgSpec `json:"-" yaml:"-"`
}

type DependencyResolutionResult struct {
	Dependency       Dependency           `json:"dependency" yaml:"dependency"`
	ExecutedCommands []bb.ExecutedCommand `json:"executed_commands" yaml:"executed_commands"`
	Met              bool                 `json:"met" yaml:"met"`
}

func (d Dependency) combineArgs(inputArguments map[string]interface{}) map[string]interface{} {
	return combineArgs(d.InputArguments, inputArguments)
}

func (d Dependency) CheckDependency(ctx context.Context, atomicsDir string, inputArguments map[string]interface{}) (*DependencyResolutionResult, error) {
	description := strings.TrimSpace(d.Description)
	log.Infof("Checking dependency: %s", description)
	executedCommand, met, err := d.checkDependency(ctx, atomicsDir, inputArguments)
	if err != nil {
		return nil, err
	}
	if met {
		log.Infof("Dependency is met: %s", description)
	} else {
		log.Warnf("Dependency is not met: %s", description)
	}
	result := &DependencyResolutionResult{
		Dependency:       d,
		ExecutedCommands: []bb.ExecutedCommand{*executedCommand},
		Met:              met,
	}
	return result, nil
}

func (d Dependency) checkDependency(ctx context.Context, atomicsDir string, inputArguments map[string]interface{}) (*bb.ExecutedCommand, bool, error) {
	inputArguments = d.combineArgs(inputArguments)
	command, err := prepareCommand(d.PrereqCommand, atomicsDir, inputArguments)
	if err != nil {
		return nil, false, err
	}
	executedCommand, err := bb.ExecuteCommand(ctx, command, d.ExecutorName, nil)
	if err != nil {
		return nil, false, err
	}
	return executedCommand, executedCommand.ExitCode == 0, nil
}

func (d Dependency) ResolveDependency(ctx context.Context, atomicsDir string, inputArguments map[string]interface{}) (*DependencyResolutionResult, error) {
	executedCommands, met, err := d.resolveDependency(ctx, atomicsDir, inputArguments)
	if err != nil {
		return nil, err
	}
	result := &DependencyResolutionResult{
		Dependency:       d,
		ExecutedCommands: executedCommands,
		Met:              met,
	}
	return result, nil
}

func (d Dependency) resolveDependency(ctx context.Context, atomicsDir string, inputArguments map[string]interface{}) ([]bb.ExecutedCommand, bool, error) {
	var executedCommands []bb.ExecutedCommand
	inputArguments = d.combineArgs(inputArguments)

	// Check if the dependency is met.
	executedCommand, met, err := d.checkDependency(ctx, atomicsDir, inputArguments)
	if err != nil {
		return executedCommands, false, err
	}
	executedCommands = append(executedCommands, *executedCommand)

	if met {
		return executedCommands, true, nil
	}

	// Resolve the dependency.
	command, err := prepareCommand(d.GetPrereqCommand, atomicsDir, inputArguments)
	if err != nil {
		return nil, false, err
	}
	executedCommand, err = bb.ExecuteCommand(ctx, command, d.ExecutorName, nil)
	if err != nil {
		return nil, false, err
	}
	executedCommands = append(executedCommands, *executedCommand)

	// Check if the dependency is met.
	executedCommand, met, err = d.checkDependency(ctx, atomicsDir, inputArguments)
	if err != nil {
		return executedCommands, false, err
	}
	executedCommands = append(executedCommands, *executedCommand)

	if met {
		return executedCommands, true, nil
	}
	return executedCommands, false, nil
}

func prepareCommand(command, atomicsDir string, inputArguments map[string]interface{}) (string, error) {
	command, err := patchAtomicsDir(command, atomicsDir)
	if err != nil {
		return "", errors.Wrap(err, "failed to patch PathToAtomicsDir")
	}
	if inputArguments != nil {
		command = interpolateArgs(command, inputArguments)
	}
	return command, nil
}

func patchAtomicsDir(command, atomicsDir string) (string, error) {
	if atomicsDir == "" {
		return command, nil
	}
	atomicsDir = strings.ReplaceAll(atomicsDir, "\\", "\\\\")
	return strings.ReplaceAll(command, "PathToAtomicsDir", atomicsDir), nil
}

func interpolateArgs(command string, inputArguments map[string]interface{}) string {
	for k, v := range inputArguments {
		command = strings.ReplaceAll(command, fmt.Sprintf("{{%s}}", k), fmt.Sprint(v))
	}
	return command
}

func combineArgs(defaultArguments map[string]ArgSpec, inputArguments map[string]interface{}) map[string]interface{} {
	m := getArgMap(defaultArguments)
	for k, v := range inputArguments {
		m[k] = v
	}
	return m
}

func getArgMap(args map[string]ArgSpec) map[string]interface{} {
	m := make(map[string]interface{})
	for k, argspec := range args {
		v := argspec.DefaultValue
		m[k] = v
	}
	return m
}
